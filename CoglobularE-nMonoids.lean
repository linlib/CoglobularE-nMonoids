
def n : Int := 1


def reflexivity {X : Type} {x : X} (p : x = x) := Eq.refl p


def symmetry {X : Type} {x : X} {y : X}  (p : x = y) := Eq.symm p


def transitivity {X : Type} {x : X} {y : X} {z : X} (p : x = y) (q : y = z) := Eq.trans p q


def extensionality (f g : X ‚Üí Y) (p : (x:X) ‚Üí f x = g x) : f = g := funext p


def equal_arguments {X : Type} {Y : Type} {a : X} {b : X} (f : X ‚Üí Y) (p : a = b) : f a = f b := congrArg f p

def equal_functions {X : Type} {Y : Type} {f‚ÇÅ : X ‚Üí Y} {f‚ÇÇ : X ‚Üí Y} (p : f‚ÇÅ = f‚ÇÇ) (x : X) : f‚ÇÅ x = f‚ÇÇ x := congrFun p x

def pairwise {A : Type} {B : Type} (a‚ÇÅ : A) (a‚ÇÇ : A) (b‚ÇÅ : B) (b‚ÇÇ : B) (p : a‚ÇÅ = a‚ÇÇ) (q : b‚ÇÅ = b‚ÇÇ) : (a‚ÇÅ,b‚ÇÅ)=(a‚ÇÇ,b‚ÇÇ) := (congr ((congrArg Prod.mk) p) q)


-- A category C consists of:
structure category.{u‚ÇÄ,v‚ÇÄ} where
  Obj : Type u‚ÇÄ
  Hom : Obj ‚Üí Obj ‚Üí Type v‚ÇÄ
  Idn : (X:Obj) ‚Üí Hom X X
  Cmp : (X:Obj) ‚Üí (Y:Obj) ‚Üí (Z:Obj) ‚Üí (_:Hom X Y) ‚Üí (_:Hom Y Z) ‚Üí Hom X Z
  Id‚ÇÅ : (X:Obj) ‚Üí (Y:Obj) ‚Üí (f:Hom X Y) ‚Üí
    Cmp X Y Y f (Idn Y) = f
  Id‚ÇÇ : (X:Obj) ‚Üí (Y:Obj) ‚Üí (f:Hom X Y) ‚Üí
    Cmp X X Y (Idn X) f = f
  Ass : (W:Obj) ‚Üí (X:Obj) ‚Üí (Y:Obj) ‚Üí (Z:Obj) ‚Üí (f:Hom W X) ‚Üí (g:Hom X Y) ‚Üí (h:Hom Y Z) ‚Üí
    (Cmp W X Z) f (Cmp X Y Z g h) = Cmp W Y Z (Cmp W X Y f g) h


-- Notation for the identity map which infers the category:
def identity_map (C : category) (X : C.Obj) := C.Idn X
notation "ùüô_(" C ")" => identity_map C



-- Notation for composition which infers the category and objects:
def composition (C : category) {X : C.Obj} {Y : C.Obj} {Z : C.Obj} (f : C.Hom X Y) (g : C.Hom Y Z) : C.Hom X Z := C.Cmp X Y Z f g
notation g "‚àò_(" C ")" f => composition C f g


theorem Id‚ÇÅ {C : category} {X : C.Obj} { Y : C.Obj} {f : C.Hom X Y} :
  (f ‚àò_(C) (ùüô_(C) X)) = f := C.Id‚ÇÇ X Y f

theorem Id‚ÇÇ {C : category} {X Y : C.Obj} {f : C.Hom X Y} :
  (ùüô_(C) Y ‚àò_(C) f) = f := C.Id‚ÇÅ X Y f

theorem Ass {C : category} {W X Y Z : C.Obj} {f : C.Hom W X} {g : C.Hom X Y} {h : C.Hom Y Z} :
  ((h ‚àò_(C) g) ‚àò_(C) f) = (h ‚àò_(C) (g ‚àò_(C) f)) := (C.Ass W X Y Z f g h)


macro "cat" : tactic => `(tactic| repeat (rw [Id‚ÇÅ]) ; repeat (rw [Id‚ÇÇ]) ; repeat (rw [Ass]))

example {C : category}
          {W : C.Obj}
          {X : C.Obj}
          {Y : C.Obj}
          {Z : C.Obj}
          {f : C.Hom W X}
          {g : C.Hom X Y}
          {h : C.Hom Y Z}
          {i : C.Hom Z W}:
     (i ‚àò_(C) (h ‚àò_(C) (g ‚àò_(C) (f ‚àò_(C) (ùüô_(C) W))) ))
  = ((i ‚àò_(C)  h) ‚àò_(C) ((ùüô_(C) Y) ‚àò_(C) g)) ‚àò_(C) (f) := by cat

‚Ñµ·∂ú·µÉ·µó
·µÉ	·µá	·∂ú	·µà	·µâ	·∂†	·µç	 ∞	‚Å±	 ≤	·µè	À°	·µê	‚Åø	·µí	·µñ	êû•	 ≥	À¢	·µó	·µò	·µõ	 ∑	À£	 ∏	·∂ª

-- obtaining a morphism from an equality
def Map (C : category) {X : C.Obj} {Y : C.Obj} (p : X = Y) : C.Hom X Y := by
subst p
exact ùüô_(C) X


notation "Map_(" C ")" p => Map C p


-- definition of an isomorphism from X to Y
structure isomorphism (C : category) (X : C.Obj) (Y : C.Obj) where
  Fst : C.Hom X Y
  Snd : C.Hom Y X
  Id‚ÇÅ : (C.Cmp X Y X Fst Snd) = C.Idn X
  Id‚ÇÇ : (C.Cmp Y X Y Snd Fst) = C.Idn Y


-- notation for isomorphisms from X to Y (‚âÖ)
notation X "‚âÖ_(" C ")" Y => isomorphism C X Y


-- defining the inverse of an isomorphism between objects X and Y
def inverse {C : category} {X : C.Obj} {Y : C.Obj} (f : X ‚âÖ_(C) Y) : Y ‚âÖ_(C) X := {Fst := f.Snd, Snd := f.Fst, Id‚ÇÅ := f.Id‚ÇÇ, Id‚ÇÇ := f.Id‚ÇÅ}


-- notation for inverse : isos from X to Y to isos from Y to X
notation f "‚Åª¬π" => inverse f


def SetObj := Type

def SetHom (X : SetObj) (Y : SetObj) : Type := X ‚Üí Y

def SetIdn (X : SetObj) : (SetHom X X) := Œª (x : X) => x


def SetCmp (X : SetObj) (Y : SetObj) (Z : SetObj) (f : SetHom X Y) (g : SetHom Y Z) : SetHom X Z := Œª (x : X) => (g (f x))


def SetId‚ÇÅ (X : SetObj) (Y : SetObj) (f : SetHom X Y) : (SetCmp X Y Y f (SetIdn Y)) = f := funext (Œª _ => rfl)

def SetId‚ÇÇ (X : SetObj) (Y : SetObj) (f : SetHom X Y) : (SetCmp X X Y (SetIdn X) f) = f := rfl

def SetAss (W : SetObj) (X : SetObj) (Y : SetObj) (Z : SetObj) (f : SetHom W X) (g : SetHom X Y) (h : SetHom Y Z) : (SetCmp W X Z f (SetCmp X Y Z g h)) = (SetCmp W Y Z (SetCmp W X Y f g) h) := funext (Œª _ => rfl)


def Set : category := {Obj := SetObj, Hom := SetHom, Idn := SetIdn, Cmp := SetCmp, Id‚ÇÅ := SetId‚ÇÅ, Id‚ÇÇ := SetId‚ÇÇ, Ass := SetAss}


-- definition of a functor
structure functor (C : category) (D : category) where
   Obj : ‚àÄ(_ : C.Obj),D.Obj
   Hom : ‚àÄ(X : C.Obj),‚àÄ(Y : C.Obj),‚àÄ(_ : C.Hom X Y),D.Hom (Obj X) (Obj Y)
   Idn : ‚àÄ(X : C.Obj),Hom X X (C.Idn X) = D.Idn (Obj X)
   Cmp : ‚àÄ(X : C.Obj),‚àÄ(Y : C.Obj),‚àÄ(Z : C.Obj),‚àÄ(f : C.Hom X Y),‚àÄ(g : C.Hom Y Z),
   D.Cmp (Obj X) (Obj Y) (Obj Z) (Hom X Y f) (Hom Y Z g) = Hom X Z (C.Cmp X Y Z f g)


--https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dependent.20type.20hell.20golfing.20challenge






-- definition of the identity functor on objects
def CatIdnObj (C : category) :=
fun(X : C.Obj)=>
X

-- definition of the identity functor on morphisms
def CatIdnMor (C : category) :=
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(f : C.Hom X Y)=>
f

-- proving the identity law for the identity functor
def CatIdnIdn (C : category) :=
fun(X : C.Obj)=>
Eq.refl (C.Idn X)

-- proving the compositionality law for the identity functor
def CatIdnCmp (C : category) :=
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(Z : C.Obj)=>
fun(f : C.Hom X Y)=>
fun(g : C.Hom Y Z)=>
Eq.refl (C.Cmp X Y Z f g)


-- defining the identity functor
def CatIdn (C : category) : functor C C :=
{Obj := CatIdnObj C, Hom := CatIdnMor C, Idn := CatIdnIdn C, Cmp := CatIdnCmp C}


-- defining the composition G ‚àò_(Cat) F on objects
def CatCmpObj (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) :=
fun(X : C.Obj)=>
(G.Obj (F.Obj X))

-- defining the composition G ‚àò_(Cat) F on morphisms
def CatCmpHom (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) :=
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(f : C.Hom X Y)=>
(G.Hom) (F.Obj X) (F.Obj Y) (F.Hom X Y f)


-- proving the identity law for the composition G ‚àò_(Cat) F
def CatCmpIdn (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) :=
fun(X : C.Obj)=>
Eq.trans (congrArg (G.Hom (F.Obj X) (F.Obj X)) (F.Idn X) ) (G.Idn (F.Obj X))


-- proving the compositionality law for the composition G ‚àò_(Cat) F
def CatCmpCmp (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) :=
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(Z : C.Obj)=>
fun(f : C.Hom X Y)=>
fun(g : C.Hom Y Z)=>
((Eq.trans)
(G.Cmp (F.Obj X) (F.Obj Y) (F.Obj Z) (F.Hom X Y f) (F.Hom Y Z g))
(congrArg (G.Hom  (F.Obj X) (F.Obj Z)) (F.Cmp X Y Z f g)))


-- defining the composition in the category Cat
def CatCmp (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) : functor C E :=
{Obj := CatCmpObj C D E F G, Hom := CatCmpHom C D E F G,Idn := CatCmpIdn C D E F G, Cmp := CatCmpCmp C D E F G}


-- proving Cat.Id‚ÇÅ
def CatId‚ÇÅ (C : category) (D : category) (F : functor C D) : ((CatCmp C D D) F (CatIdn D) = F) := Eq.refl F

-- Proof of Cat.Id‚ÇÇ
def CatId‚ÇÇ (C : category) (D : category) (F : functor C D) : ((CatCmp C C D) (CatIdn C) F = F) := Eq.refl F

-- Proof of Cat.Ass
def CatAss (B : category) (C : category) (D : category) (E : category) (F : functor B C) (G : functor C D) (H : functor D E) : (CatCmp B C E F (CatCmp C D E G H) = CatCmp B D E (CatCmp B C D F G) H) :=
Eq.refl (CatCmp B C E F (CatCmp C D E G H))


-- The category of categories
universe u
universe v
def Cat : category := {Obj := category.{u, v}, Hom := functor, Idn := CatIdn, Cmp := CatCmp, Id‚ÇÅ:= CatId‚ÇÅ, Id‚ÇÇ:= CatId‚ÇÇ, Ass := CatAss}


notation "ùüô" X => ùüô_(Cat) X

notation g "‚àò" f => g ‚àò_(Cat) f


-- defining the objects of the CatPrd C D
def CatPrdObj (C : category) (D : category) := (D.Obj) √ó (C.Obj)

-- defining the morphisms of CatPrd C D
def CatPrdHom (C : category) (D : category) (X : CatPrdObj C D) (Y : CatPrdObj C D) := (D.Hom X.1 Y.1) √ó (C.Hom X.2 Y.2)

-- defining the identity functor on an object in C √ó D
def CatPrdIdn (C : category) (D : category) (X : CatPrdObj C D) := ((D.Idn X.1),(C.Idn X.2))

-- defining the composition on morphisms in C √ó D
def CatPrdCmp (C : category) (D : category) (X : CatPrdObj C D) (Y : CatPrdObj C D) (Z : CatPrdObj C D) (f : CatPrdHom C D X Y) (g : CatPrdHom C D Y Z) : CatPrdHom C D X Z := (D.Cmp X.1 Y.1 Z.1 f.1 g.1, C.Cmp X.2 Y.2 Z.2 f.2 g.2)


-- proving the first identity law for morphisms in C √ó_Cat D
theorem CatPrdId‚ÇÅ (C : category) (D : category) (X : CatPrdObj C D) (Y : CatPrdObj C D) (f : CatPrdHom C D X Y) :
  CatPrdCmp C D X Y Y f (CatPrdIdn C D Y) = f := sorry

-- proving the second identity law for morphisms in C √ó_Cat D
theorem CatPrdId‚ÇÇ (C : category) (D : category) (X : CatPrdObj C D) (Y : CatPrdObj C D) (f : CatPrdHom C D X Y) : CatPrdCmp C D X X Y (CatPrdIdn C D X) f = f := sorry

-- proving associativity for morphisms in C √ó_Cat D
theorem CatPrdAss
  (C : category) (D : category)
  (W : CatPrdObj C D) (X : CatPrdObj C D)
  (Y : CatPrdObj C D) (Z : CatPrdObj C D)
  (f : CatPrdHom C D W X) (g : CatPrdHom C D X Y) (h : CatPrdHom C D Y Z) :
  CatPrdCmp C D W X Z f (CatPrdCmp C D X Y Z g h) = CatPrdCmp C D W Y Z (CatPrdCmp C D W X Y f g) h := sorry


-- defining the CatPrd of two categories
def CatPrd (C : category) (D : category) : category := {Obj := CatPrdObj C D, Hom := CatPrdHom C D, Idn := CatPrdIdn C D, Cmp := CatPrdCmp C D, Id‚ÇÅ := CatPrdId‚ÇÅ C D, Id‚ÇÇ:= CatPrdId‚ÇÇ C D, Ass := CatPrdAss C D}


notation:1000  D "√ó_Cat" C => CatPrd C D


def FunPrdObj
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ) :
  (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj ‚Üí (D‚ÇÅ √ó_Cat D‚ÇÇ).Obj :=
  sorry


def FunPrdHom
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ)
  (X : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (Y : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (f : (C‚ÇÅ √ó_Cat C‚ÇÇ).Hom X Y) :
  ((D‚ÇÅ √ó_Cat D‚ÇÇ).Hom (FunPrdObj F G X) (FunPrdObj F G Y) ) :=
  sorry


def FunPrdIdn
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ)
  (X : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj) :
  (FunPrdHom F G X X ((C‚ÇÅ √ó_Cat C‚ÇÇ).Idn X))  = ((D‚ÇÅ √ó_Cat D‚ÇÇ).Idn (FunPrdObj F G X)) :=
  sorry


def FunPrdCmp
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ)
  (X : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (Y : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (Z : (C‚ÇÅ √ó_Cat C‚ÇÇ).Obj)
  (f : (C‚ÇÅ √ó_Cat C‚ÇÇ).Hom X Y)
  (g : (C‚ÇÅ √ó_Cat C‚ÇÇ).Hom Y Z) :
  ((D‚ÇÅ √ó_Cat D‚ÇÇ).Cmp (FunPrdObj F G X) (FunPrdObj F G Y) (FunPrdObj F G Z) ((FunPrdHom F G) X Y f) (FunPrdHom F G Y Z g)) = (FunPrdHom F G X Z ((C‚ÇÅ √ó_Cat C‚ÇÇ).Cmp X Y Z f g)) :=
  sorry


def FunPrd
  {C‚ÇÅ : category}
  {D‚ÇÅ : category}
  {C‚ÇÇ : category}
  {D‚ÇÇ : category}
  (F : Cat.Hom C‚ÇÅ D‚ÇÅ)
  (G : Cat.Hom C‚ÇÇ D‚ÇÇ) :
  Cat.Hom (C‚ÇÅ √ó_Cat C‚ÇÇ) (D‚ÇÅ √ó_Cat D‚ÇÇ) :=
  {Obj := FunPrdObj F G, Hom := FunPrdHom F G, Idn := FunPrdIdn F G, Cmp := FunPrdCmp F G}


notation F "√ó_Fun" G => FunPrd F G


-- defining the category *_Cat
def PntObj : Type := Unit
def PntHom (_ : PntObj) (_ : PntObj) : Type := Unit
def PntIdn (X : PntObj) : PntHom X X := Unit.unit
def PntCmp (X : PntObj) (Y : PntObj) (Z : PntObj) (_ : PntHom X Y) (_ : PntHom Y Z) : PntHom X Z := Unit.unit
def PntId‚ÇÅ (X : PntObj) (Y : PntObj) (f : PntHom X Y) : PntCmp X Y Y f (PntIdn Y) = f := Eq.refl f
def PntId‚ÇÇ (X : PntObj) (Y : PntObj) (f : PntHom X Y) : PntCmp X X Y (PntIdn X) f = f := Eq.refl f
def PntAss (W : PntObj) (X : PntObj) (Y : PntObj) (Z : PntObj) (f : PntHom W X) (g : PntHom X Y) (h : PntHom Y Z) : PntCmp W Y Z (PntCmp W X Y f g) h = PntCmp W X Z f (PntCmp X Y Z g h) := Eq.refl Unit.unit
def Pnt : category := {Obj := PntObj, Hom := PntHom, Idn := PntIdn, Cmp := PntCmp, Id‚ÇÅ := PntId‚ÇÅ, Id‚ÇÇ := PntId‚ÇÇ, Ass := PntAss}


-- notation for the category *_Cat
notation "*_Cat" => Pnt

